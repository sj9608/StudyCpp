04-1 정보은닉(Information Hiding)
---

**정보은닉의 이해**

![image](https://user-images.githubusercontent.com/52594760/103167022-f7705700-486a-11eb-9294-ce7896442553.png)

윈도우 그림판 프로그램과 유사한 성격의 프로그램을 C++에서 구현한다고 가정해 보았을 때 점의 위치를 표현하는 클래스는 기본적으로 필요하다.
``` C++
class Point
{
public:
    int x; // 0 ~ 100
    int y; // 0 ~ 100
};
```
위 클래스에서 x, y의 범위는 0~100 이하이고 좌상단이 [0, 0] 우하단이 [100, 100] 이라 가정하였을 때 아래 예제에서 발생할 수 있는 문제가 있다.
> 01_RectangleFault.cpp

위 예제 31행의 문장에 의해 생성되는 객체는 메모리상에 다음의 형태로 존재한다.
``` C++
Rectangle rec = {pos2, pos1};
```
![image](https://user-images.githubusercontent.com/52594760/103167177-381ca000-486c-11eb-8a66-ec83fcc99dcb.png)

위 그림에서 보이듯 Rectangel 객체안에 두 개의 Point객체가 포함되어 있다.
Rectangle rec = {pos2, pos1};

위 문장은 객체를 생성하고 초기화 하는 문장이다. 미리 생성해 놓은 Point 객체에 저장된 값이 Rectangle 객체의 멤버에 대입된다.

자 이제 문제를 지적해보자
* 점의 좌표 범위는 0~100 이하가 되어야 하는데, 그렇지 못한 Point객체가 있다.
* 직사각형을 의미하는 Rectangle 객체의 좌 상단 좌표값이 우 하단 좌표값 보다 크다. 

> 프로그래머의 실수에 대한 대책이 준비되어 있지 않다는게 문제이다.

제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고, 또 실수륵 했을 때, 실수가 쉽게 발견되도록 해야 한다.

> 이를 해결한 02_Point 클래스를 확인해보자

먼저 멤버변수 x, y를 private으로 선언해 임의로 값이 저장되는것을 막았다.
대신 값의 저장 및 참조를 위한 함수를 추가로 정의하였다. 따라서 이 함수내에서 멤버 변수에 저장되는 값을 제한 할 수 있게 되엇다.

> 함수들의 정의를 확인하기 위해 02_Point.cpp 예제를 확인하자.

**"멤버변수를 private으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것이 바로 '정보은닉'이며, 이는 좋은 클래스가 되기 위한 기본조건이 된다!"**

02 예제를 보면 변수이름이 X일 때, 다음과 같이 GetX, SetX 로 정의된 함수들을 볼 수 있다.
``` C++
int GetX() const;
int SetX(int xpos);

int GetY() const;
int GetY(int ypos);
```

이들을 가리켜 **엑세스 함수(Access Function)** 라고 하는데, 이들은 멤버변수를 private으로 선언하면서 클래스 외부에서 멤버변수의 접근을 목적으로 정의되는 함수들이다. 

함수가 정의 되었음에도 호출되지 않는 경우가 많다.
> 왜 Why ?

클래스 정의과정에 당장 필요하지 않지만, 필요할 수 있다고 판단되는 함수들도 더불어 멤버에 포함시키는 경우가 많다. 대표적인 예가 **엑세스 함수**이다. 

---
> 정보가 은닉된 03_Rectangle.h 클래스와 함수의 정의가 담긴 03_Rectangle.cpp 를 확인하자.

> 02_Point, 03_Rectangle 클래스 대상으로 정의된 03_main함수를 확인하자

모든 함수들이 초기화의 실패 여부에 따라서 true, false를 반환하도록 정의했기 때문에, 함수 호출영역에서 성공여부를 확인하고 그에 따른 조치를 취할 수 있다.

---
**Const 함수**
앞서 보인 예제 02_Point.h와 03_Rectangle.h에 선언된 다음 함수들에는 const 선언이 추가되어 있다.
``` C++
int GetX() const;
int GetY() const;
void ShowRecInfo() const;
```
이 const는 다음 내용을 선언하는 것이다.
> 이 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다!

const 선언이 추가된 멤버함수 내에서 멤버변수의 값을 변경하는 코드가 삽입되면, 컴파일 에러가 발생한다.
이를 통해 실수로 멤버변수의 값을 변경했을때 컴파일 에러를 통해 확인할 수 있다. **프로그래머의 실수를 최소화** 하기 위한 매우 의미있는 선언이다.

또 한가지 ❗️중요한점❗️이 있다
> const 함수 내에서는 const가 아닌 함수의 호출이 제한된다!

const로 선언되지 않은 함수는 값을 변경할 여지가 있기 때문에 이러한 변경이 가능한 함수의 호출을 아예 허용하지 않는다.

또한 
``` C++
int GetNum() // const 함수일 경우 컴파일에러 해결가능
{
    return num;
}

void InitNum(const EasyClass &easy)
{
    num = easy.GetNum();
}
```
이와 같이 'const 참조자' easy 를 매개변수로 한 InitNum 함수 안에서 역시 GetNum() 이란 일반 함수의 호출이 불가능하다 

**문제 04-1[정보은닉과 const]**