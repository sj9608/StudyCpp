04-3 생성자(Constructor)와 소멸자(Destructor)
---

객체를 생성하고 객체의 멤버변수를 초기화 하기위해 InitMember라는 이름의 함수를 정의하고 호출하였다.  정보은닉을 목적으로 멤버변수들을 private으로 선언 했지만 이는 불편하다. 이를 보완해 '생성자'라는 것을 이용하면 객체도 생성과 동시에 초기화 할 수 있다.

**생성자의 이해**
``` C++
class SimpleClass
{
private:
    int num;
public:
    SimpleClass(int n) // 생성자(constructor)
    {
        num = n;
    }
    int GetNum() const
    {
        retrun num;
    }
};
```
이 클래스 정의에서 다음의 형태를 띄는 함수가 있다.
* 클래스의 이름과 함수의 이름이 동일하다.
* 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.

이러한 유형의 함수를 가리켜 **생성자** 라고 하며 이는 다음의 특징을 갖는다.
> "객체 생성시 딱 한번 호출된다."

이전에 생성자를 정의하지 않았을 때. 우리는 다음과 같은 방법으로 객체를 생성하였다.
``` C++
SimpleClass sc; // 전역, 지역 및 매개변수의 형태 (스택)
SimpleClass * ptr = new SimpleClass; // 동적할당 (힙)
```
그러나 생성자가 정의 되었으니, 객체 생성과정에서 자동으로 호출되는 생성자에게 전달할 인자의 정보를 다음과 같이 추가해야 한다.
``` C++
SimpleClass sc(20); // 생성자에 20 전달.
SimpleClass * ptr = new SimpleClass(30); // 생성자에 30 전달
```
---
지금까지 설명한 내용을 바탕으로 다음 두 가지 사실을 추가로 설명한다.
* 생성자도 함수의 일종이니 오버로딩이 가능하다.
* 생성자도 함수의 일종이니 매개변수에 '디폴트 값'을 설정할 수 있다.

> 01_Constructor1.cpp 예제확인

정의된 생성자를 이용해 객체를 생성하기 위해 다음 문장을 구성하면 안된다
``` C++
SimpleClass sc1(); ❌
```
이것이 main문 안에 쓰여졌을 경우 함수의 원형 선언인지, 함수의 호출인지 구분할 수 없기 때문에 이것은 함수의 원형 선언으로 약속해 두었다. (컴파일 에러는 없음)

**이전 예제에 대한 활용**
Chapter03 예제 FruitSaleSim1.cpp에 생성자를 적용해보겠다.
> 02_FruitSaleSim2.cpp 예제를 확인하자.

**"멤버 이니셜라이저"를 이용한 멤버 초기화**
> 폴더 03_initializer 를 확인하자.

Rectangle 클래스에서 Point 객체의 생성과 초기화를 하기 위한 예제이다.
``` C++
class Rectangle
{
private:
    Point upLeft;
    Point lowRight;
public:
    Rectnagle(const int &x1, const int &y1, const int &x2, const int &y2);
    void ShowRecInfo() const;
}; // 선언

// 생성자 (이니셜라이저 포함)
Rectangle::Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
            :upLeft(x1, y1), lowRight(x2, y2)
```
이 중에서 다음 내용이 **'멤버 이니셜라이저'** 이다.
``` C++
:upLeft(x1, y1), lowRight(x2, y2)
```
이것이 의미하는 바는 다음과 같다.
* 객체 upLeft의 생성과정에서 x1, y1을 인자로 전달받는 생성자를 호출하라.
* 객체 lowRight 생성과정에서 x2, y2을 인자로 전달받는 생성자를 호출하라.

이렇듯 멤버 이니셜라이저는 멤버 변수로 선언된 객체의 생성자 호출에 활용된다. 

---
예제 03 까지 살펴본 결과 우리는 객체의 생성과정을 다음과 같이 정리할 수 있다.
* 1단계 : 메모리 공간에 할당
* 2단계 : 이니셜라이저를 이용한 멤버변수(객체) 초기하
* 3단계 : 생성자의 몸체부분 실행

C++의 모든 객체는 위의 세가지 과정을 순서대로 거쳐서 생성이 완성된다. 물론 이니셜라이저가 선언되지 않았다면, 메모리 공간의 할당과 생성자의 몸체부분의 실행으로 객체생성은 완성된다.

**생성자를 정의하지 않아도 생성자는 반드시 호출이 된다.**
(디폴트 생성자가 컴파일러에 의해 자동으로 생성되고 호출된다.)

**멤버 이니셜라이저를 이용한 변수 및 const 상수 초기화**
'멤버 이니셜라이저'는 객체가 아닌 멤버의 초기화 에도 사용할 수 있다.
``` C++
class Simple
{
private:
    int num1, num2;
public:
    Simple(int n1, int n2) : num1(n1) ❗️
    {
        num2 = n2;
    }
};
```
위 코드에서 :num1(n1) 문장은 num1을 n1의 값으로 초기화 하는 뜻이 된다.

프로그래머는 생성자의 몸체에서 초기화 하는 방법과 이니셜라이저를 이용하는 초기화 방법중에 한가리르 선택할 수 있다. ❗️그러나 **일반적으로 멤버변수는 이니셜라이저를 선호**한다. 이유는 다음과 같다.
* 초기화의 대상을 명확히 인식할 수 있다.
* 성능에 약간의 이점이 있다.

❗️❗️이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다.
``` C++
:num1(n1) --> int num1 = n1; // 선언과 동시에 초기화

int num2 = n2; // 사실상 컴파일러는 아래처럼 행동한다

int num2;
num2 = n2;
```

이러한 사실로부터 한가지 중요한 가능성을 발견하게 된다.
> const 멤버 변수도 이니셜라이저를 이용하면 초기화가 가능하다.

const변수는 선언과 동시에 초기화를 해야한다. 하지만 이니셜라이저를 이용하지 않으면 초기화 할 수 없다.

**이니셜라이저는 멤버변수로 참조자를 선언할 수 있게한다**
const 변수와 마찬가지로 '참조자'도 선언과 동시에 초기화가 이뤄져야 한다. 이 특성을 파악하기 위해 다음 예제를 참조하자
> 04_ReferencMember.cpp

**소멸자의 이해와 활용**
객체 생성시 반드시 호출되는 것이 생성자라면, 객체소멸시 반드시 호출되는 것은 소멸자이다. 소멸자는 다음의 형태를 갖는다
* 클래스의 이름앞에 '~' 가 붙은형태의 이름을 갖는다.
* 반환형이 선언되지 않으며 실제로 반환하지 않는다.
* 매개변수는 void형으로 선언되어야 하기 때문에 오버로딩, 디폴트값 설정 불가능하다.

이러한 소멸자는 대개 생성자에서 할당한 리소스의 소멸에 사용된다.
예를 들어 new 연산자를 이용해 할당해 놓은 메모리공간이 있다면, 소멸자에서는 delete 연산자를 이용해 이 메모리 공간을 소멸한다.
> 예제 05_Destructor.cpp 확인

**문제 04-3 [C++ 기반의 데이터 입출력]**
> Question04-3 폴더 확인



