04-3 생성자(Constructor)와 소멸자(Destructor)
---

객체를 생성하고 객체의 멤버변수를 초기화 하기위해 InitMember라는 이름의 함수를 정의하고 호출하였다.  정보은닉을 목적으로 멤버변수들을 private으로 선언 했지만 이는 불편하다. 이를 보완해 '생성자'라는 것을 이용하면 객체도 생성과 동시에 초기화 할 수 있다.

**생성자의 이해**
``` C++
class SimpleClass
{
private:
    int num;
public:
    SimpleClass(int n) // 생성자(constructor)
    {
        num = n;
    }
    int GetNum() const
    {
        retrun num;
    }
};
```
이 클래스 정의에서 다음의 형태를 띄는 함수가 있다.
* 클래스의 이름과 함수의 이름이 동일하다.
* 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.

이러한 유형의 함수를 가리켜 **생성자** 라고 하며 이는 다음의 특징을 갖는다.
> "객체 생성시 딱 한번 호출된다."

이전에 생성자를 정의하지 않았을 때. 우리는 다음과 같은 방법으로 객체를 생성하였다.
``` C++
SimpleClass sc; // 전역, 지역 및 매개변수의 형태 (스택)
SimpleClass * ptr = new SimpleClass; // 동적할당 (힙)
```
그러나 생성자가 정의 되었으니, 객체 생성과정에서 자동으로 호출되는 생성자에게 전달할 인자의 정보를 다음과 같이 추가해야 한다.
``` C++
SimpleClass sc(20); // 생성자에 20 전달.
SimpleClass * ptr = new SimpleClass(30); // 생성자에 30 전달
```
---
지금까지 설명한 내용을 바탕으로 다음 두 가지 사실을 추가로 설명한다.
* 생성자도 함수의 일종이니 오버로딩이 가능하다.
* 생성자도 함수의 일종이니 매개변수에 '디폴트 값'을 설정할 수 있다.

> 01_Constructor1.cpp 예제확인

정의된 생성자를 이용해 객체를 생성하기 위해 다음 문장을 구성하면 안된다
``` C++
SimpleClass sc1(); ❌
```
이것이 main문 안에 쓰여졌을 경우 함수의 원형 선언인지, 함수의 호출인지 구분할 수 없기 때문에 이것은 함수의 원형 선언으로 약속해 두었다. (컴파일 에러는 없음)

**이전 예제에 대한 활용**
Chapter03 예제 FruitSaleSim1.cpp에 생성자를 적용해보겠다.
> 02_FruitSaleSim2.cpp 예제를 확인하자.

