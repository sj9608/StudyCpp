13-1  템플릿에 대한 이해와 함수 템플릿
---

**함수를 대상으로 템플릿 이해하기**

'함수 템플릿'의 특징
> 함수 템플릿은 함수를 만들어낸다. 함수의 기능은 결정되어 있지만, 자료형은 결정되어 있지 않아서 결정해야 한다.

'함수 템플릿'은 **다양한 자료형의 함수를 만드는 도구가 된다.**

다음의 예를 통해 함수 템플릿을 구체적으로 이해해보자.
``` C++
int Add(int num1, int num2)
{
    return num1+num2;
}
```
위 함수의 기능과 자료형은 다음과 같다.
* 기능 ➡️ 덧셈
* 대상 자료형 ➡️ int형 데이터

이러한 함수를 만들어 낼 수 있는 템플릿은 다음과 같이 정의한다.

``` C++
T Add(T num1, T num2)
{
    return num1 + num2;
}
```

이를 앞서 정의한 Add 함수와 비교해 보면, int형 선언을 T로 대신했음을 알 수 있는데, 이는 자료형을 결정 짓지 않은, 그래서 나중에 T를 대신해서 실제 자료형을 결정하겠다는 뜻이다.
위 함수 템플릿의 기능과 자료형은 다음과 같다.
* 기능 ➡️ 덧셈
* 대상 자료형 ➡️ 결정되어 있지 않음

우리는 컴파일러에게 다음과 같은 메시지를 전달해야 한다.
> T는 자료형을 결정짓지 않겠다는 의미로 사용한 것입니다. 함수를 만들어내는 템플릿을 정의하기 위해 사용된 것입니다.

``` C++
template <typenmae T>
T Add(T num1, T num2)
{
    return num1 + num2;
}
```

위 문장의 첫 행의 의미는 다음과 같다.
> T라는 이름을 이용해서 아래의 함수를 템플릿으로 정의한다는 의미이다.

**typename을 대신해서 class 를 사용할 수도 있다.**
``` C++
template <typename T>
template <class T>
둘 다 흔히, 사용되니 이 두가지 선언은 같은 의미라는 사실을 기억하자.
물론 T라는 문자 대신 다른 문자를 사용해도 된다.
```

앞서 정의한 함수 템플릿을 이용해서 함수를 만들 차례이다.

``` C++
template <typename T>
T Add(T num1, T num2)
{
    return num1 + num2;
}

int main(void)
{
    cout << Add<int>(15, 20) << endl;
    cout << Add<double>(2.9, 3.7) << endl;
    cout << Add<int>(3.2, 3.2) << endl;
    cout << Add<double>(3.14, 2.75) << endl;
    
    return 0;
}
```

main 함수에서 Add<int>(15, 20) 구문이 등장하는데 이 의미는 다음과 같다.
> T를 int로 해서 만들어진 Add함수를 호출한다.

그래서 컴파일러는 이 문장을 보는 순간 다음의 형태로 함수를 하나 만든다.

``` C++
int Add(int num1, int num2)
{
    return num1 + num2;
}
```

위의 main 함수에선 int형 함수와 double형 함수가 호출되었는데
이는 컴파일을 할 때 처음으로 함수를 만든뒤 두 번째 호출부터는 한번 생성되었던 함수를 재 호출한다.
따라서 실행속도에 감소를 발생시키지 않고 컴파일 하는데 걸리는 시간이 늘어나는 것이다.

그리고 컴파일 함수가 호출될때 생성되는 함수는 다음과 같이 표현하는것이 정확하다.
``` C++
int Add<int>(int num1, int num2)
{
    return num1 + num2;
}

double Add<double>(double num1, double num2)
{
    return num1 + num2;
}
```

**호출하기 불편하다?**
위에서 보인예제의 main 함수는 다음과 같이 일반함수를 호출하듯이 변경해도 된다. 왜냐하면, 전달되는 인자의 자료형을 참조하여 호출될 함수의 유형을 컴파일러가 결정하기 때문이다.

``` C++
int main(void)
{
    cout << Add(15, 20) << endl;
    cout << Add(2.9, 3.7) << endl;
    cout << Add(3.2, 3.2) << endl;
    cout << Add(3.14, 2.75) << endl;
    return 0;
}
```

예를 들어 Add(3.5, 4.5) 의 호출 문을 보면 컴파일러는 다음과 같이 판단한다.
> 전달되는 인자의 자료형이 double이니 함수 템플릿의 T가 double이 되어야 값의 손실 없이 인자를 전달받을 수 있겠구나.

때문에 위 예제의 main 함수를 실행했을 때의 결과는 다음과 같이 나타난다.
``` bash
35
6.6
6.4
5.89
```

**함수 템플릿과 템플릿 함수**
템플릿 함수의 정의를 가리켜 함수 템플릿 이라 하고
템플릿을 기반으로 컴파일러가 만들어 내는 다음 유형의 함수들을 가리켜 '템플릿 함수' 라 한다.

즉 함수 템플릿은
> 함수를 만드는데 사용되는 템플릿

템플릿 함수는
> 템플릿을 기반으로 만들어진 함수

라고 정의할 수 있다.

그런데 이렇게 만들어지는 템플릿 함수는 일반함수와 구분이 된다. 따라서 두 가지 모두 함께 존재할 수 있는데, 이는 다음 예제를 통해 확인하자.

> 02_TwoTypeAddFunction.cpp

이 예제에서는 함수 템플릿을 정의한 상황에서 일반함수까지 정의하는 것은 바람직하지 못하다는 사실과 컴파일러에 의해 만들어지는 템플릿 함수가 일반함수와 구분된다는 사실을 보여준다.

**둘이상의 형(Type)에 대해 템플릿 선언하기**

> 03_PrimitiveFunctionTemplate.cpp

위 처럼 함수 템플릿 선언시 둘 이상의 템플릿 타입을 명시할 수 있다. 그리고 typename 대신 키워드 class를 사용할 수 있다.

``` C++
void ShowData(double num)
{
    cout << (T1)num << ", " << (T2)num << endl;
    위 함수는 아래와 같이 대체할 수 있다.
    cout << T1(num) << ", " << T2(num) << endl;
}
```
데이터에 소괄호를 묶는 형태로 형변환을 명령할 수 잇다. 즉, 
int num = (int)3.14;
int num = int(3.14); 
두 문장은 완전히 일치한다.

**함수 템플릿의 특수화(Specialization)**
이번에는 '함수 템플릿의 특수화'라는 것에 대해 설명할 텐데, 이에 앞서 다음 에제와 실행결과를 관측해보자.
> 04_NeedSpecialFunctionTemplate.cpp

위 예제의 Max 함수는 전달된 두 인자 데이터 중 큰 값을 반환하도록 정의되어 있지만 문자열 대상으로 호출할 경우엔 단순히 주소값의 비교결과가 반환되므로 의미를 부여할 수 없다. 만약 문자열 길이의 비교가 목적이라면 다음의 형태로 템플릿 함수가 구성되어야 의미가 있다.

``` C++
const char* Max(const char *a, const char *b)
{
    return strlen(a) > strlen(b) ? a : b ;
}
```

사전 순서 비교가 목적이라면 다음 형태로 템플릿 함수가 구성되어야 의미가 있다.
``` C++
char* Max(const char *a, const char *b)
{
    return strcmp(a, b) > 0 ? a : b ;
}
```

이처럼 상황에 따라 함수의 구성방법에 예외를 둘 필요가 있는데, 이때 사용되는 것이 '함수 템플릿의 특수화' 이다. 다음 예제를 확인하자.

> 05_SpecialFunctionTemplate.cpp

``` C++
template <>
char * Max(char * a, char * b)
{
    . . .
}
```
위의 정의는 컴파일러에게 다음의 메세지를 전달하는 것이다.

> char* 형 함수는 내가 이렇게 제시를 하니, char * 형 템플릿함수가 필요한 경우에는 별도로 만들지 말고 위에 정의한것을 사용해라. 마찬가지로 const char* 형도 따로 정의해두었다.

그리고 이 두 '함수 템플릿의 특수화' 정의형태는, 특수화 하는 자료형의 정보 char* 와 const char*를 생략한 형태이며, 이를 생략하지 않고 정의하면 다음의 형태가 된다.

``` C++
template <>
char * Max<char *>(char * a, char * b) { . . . }
template <>
const char * Max(const char * a, const char * b) { . . . }
```