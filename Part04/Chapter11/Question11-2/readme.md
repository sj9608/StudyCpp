문제 11-2 [C++ 기반의 데이터 입출력]
---
#### 문제 1
11-2 에제 05_StablePointPtrArray.cpp의 65, 66행을 다음과 같이 구성할 수 있도록 Point 클래스를 대상으로 연산자 오버로딩을 진행해보자.
``` C++
for(int i = 0 ; i < arr.GetArrLen() ; i++)
    cout << arr[i];
```
물론 실행 결과에는 변함이 없도록 연산자를 오버로딩 해야한다.

#### 문제 2
2차원 배열 접근자에 대한 연산자 오버로딩을 진행하고자 한다. 실제로 이렇게 까지 연산자를 직접 오버로딩 하는 경우는 거의 없다. 다만, 호기심 유발과 충족을 위해 이문제를 제시한다. 호기심과 즐거움을 느꼈으면 좋겠따.
``` C++
class BoundCheck2DIntArray { . . . . }
```
이 클래스는 BoundCheckIntArray 클래스의 2차원 배열버전이다. 따라서 다음과 같이 객체를 생성하면, 
``` C++
BoundCheck2DIntArray arr2d(3, 4);
```

세로와 가로의 길이가 각각 3과 4인, int형 2차원 배열처럼 동작하는 arr2d 객체가 생성되어, 다음의 형태로 데이터를 저장 및 참조할 수 있어야 한다.
``` C++
for(int n=0; n<3; n++)
{
    for(int m=0; m<4; m++)
        arr2d[n][m] = n + m;
}

for(int n=0; n<3; n++)
{
    for(int m = 0; m < 4; m++)
        cout << arr2d[n][m] << ' ';
    cout << endl;
}
```
참고로 두 개의 [ ] 연산자를 동시에 오버로딩 하는 것은 허용되지 않기 때문에, 위의 다음 문장은, 
```
arr2d[n][m];
```
두 번의 [ ] 연산자 호출을 동반하게끔 구현해야 한다. 즉, 첫 번째 [ ] 연산에 의해서 위의 문장은 다음과 같이 해석되어야 하며,
``` C++
(arr2d.operator[](n))[m];
```
그리고 2d.operator[](n) 연산의 반환 값을 이용해서 두 번째 [ ] 연산은 다음과 같이 해석되어야 한다.
((반환값).operator[])(m);

참고로 이는 호기심 유발 이상의 의미를 갖지는 않지만 제법 수준이 높은 문제이니 풀지 못했다고 해서 실망 할 필요는 없다.