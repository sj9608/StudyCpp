11-1 반드시 해야 하는 대입 연산자의 오버로딩
---
대입연산자의 오버로딩은 그 성격이 복사 생성자와 매우 유사하다. 따라서 복사 생성자에 대한 이해를 바탕으로 대입 연산자의 오버로딩을 이해하자.

**객체간 대입 연산의 비밀 : 디폴트 대입 연산자**
복사 생성자에 대한 대표적인 특성이다.
* 정의하지 않으면 디폴트 복사 생성자가 삽입된다.
* 디폴트 복사 생성자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
* 생성자 내에서 동적할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의 해야한다.

다음은 대입 연산자의 대표적인 특성이다.
* 정의하지 않으면 **디폴트 대입 연산자**가 삽입된다.
* 디폴트 대입 연산자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
* 연산자 내에서 동적할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의 해야한다.

개념만 놓고 보면 특성은 같지만 **호출되는 시점**에는 차이가 있다.

복사 생성자가 호출되는 대표적인 상황은 다음과 같다.
``` C++
int main(void)
{
    Point pos1(1, 5);
    Point pos2 = pos1;
    . . . .
}
```

여기서 중요한 사실은 새로 생성하는 객체 pos2의 초기화에 기존에 생성된 객체 pos1이 사용 되었다는 점 이다.

다음은 대입연산자가 호출되는 대표적인 상황이다.
``` C++
int main(void)
{
    Point pos1(5, 7);
    Point pos2(9, 10);
    pos2 = pos1;
    . . . .
}
```
여기서 중요한 사실은 **pos2도, 그리고 pos1도 이미 생성 및 초기화가 진행된 객체라는 사실**이다. 즉, 기존에 생성된 두 객체간의 대입연산 시에는 대입 연산자가 호출된다. 

그런데 우리는 이미 연산자 오버로딩을 공부한 상태이니 위의 대입연산의 문장은 다음과 같이 해석됨을 알 수 있다.

``` C++
pos2.operator=(pos1);
```

그럼 지금까지 언급한 대입 연산자의 특성을 확인하기 위한 예제를 하나 제시하겠다. 이 예제에서는 두 개의 클래스를 정의하는데, 한 클래스에는 대입연산자를 정의했고, 다른 클래스에는 대입연산자를 정의 하지 않았다.
> 01_FirstOperationOverloading.cpp

위의 실행결과를 통해서 확인 할 수 있는 사실은 다음과 같다.
> 분명 디폴트 대입 연산자가 삽입되어 멤버 대 멤버의 복사가 진행된다.

그리고 fob1 = fob2 = fsrc; 구문을 통해서 반환형도 예측이 가능하다. 즉, 위에서 정의한 First 클래스에 자동으로 삽입된 디폴트 연산자는 다음과 같다.

``` C++
First& operator=(const First& ref)
{
    num1 = ref.num1;
    num2 = ref.num2;
    return *this;
}
```

따라서 위의 함수를 First 클래스에 직접 삽입해도 실행 결과에는 차이가 없다. 참고로 우리는 다음의 문장을 보면, 

``` C++
int main(void)
{
    Second s1(10, 20);
    Second s2(11, 22);
    s2 = s1;
    . . .
}
```

> 동일한 자료형의 두 객체간에 대입연산이 허용되네?

위와 같이 생각 할 수 있다. 그러나 앞서 보였듯이, 객체간의 대입연산은 C언어의 구조체 변수간의 대입연산과 본질적으로 다르다.

이는 단순한 대입연산이 아닌, 대입 연산자 오버로딩을 한 함수의 호출이기 때문이다.

**디폴트 대입 연산자의 문제점**
기존에 보였던 디폴트 복사 생성자와 비슷한 문제이다. 물론 해결책도 비슷하다. 
이 예제는 Chapter05에서 디폴트 복사 생성자의 문제점을 언급할 때 사용했던 예제를 수정한 것이다.

> 02_AssignShallowCopyError.cpp

위 실행결과를 확인해보면 소멸자가 1번 호출되었다. 디폴트 복사 생성자와같은 문제가 생겼음을 알 수있다.

man2 = man1로 인해 디폴트 대입 연산자가 호출되면 디폴트 대입 연산자는 멤버 대 멤버를 단순히 복사만 하므로, 같은 포인터주소를 참조하게 된다.
<img width="400" alt="image" src="https://user-images.githubusercontent.com/52594760/104122602-5c5a9f80-5389-11eb-9345-64af98598aa7.png">


이렇듯 하나의 문자열을 두 개의 객체가 동시에 참조하는 상황이 벌어지게 되며, 이로 인해 다음의 두 가지 문제가 발생하게 된다.
* 문자열 "Yoon ji yul"을 가리키던 문자열의 주소 값을 잃게 된다.
* 얕은 복사로 인해서, 객체 소멸과정에서 지워진 문자열을 중복 소멸하는 문제가 발생하게 된다.

우선 문자율 "Yoon ji yul" 을 가리키던 주소 값을 잃게 되므로 더이상 이 문자열에 접근이 불가능하다. 때문에 소멸도 불가능한 상태가 되어 메모리의 누수로 이어진다.

그리고 두 객체중 하나가 소멸되면서(man2) 소멸자의 다음 문장이 실행된다.
``` C++
delete []name;
```
이로 인해서 문자열 "Lee dong woo" 도 함께 소멸이 되어 다음의 형태가 된다.
문자열 "Yoon ji yul" 은 누수된 상태로 존재한다.
<img width="400" alt="image" src=https://user-images.githubusercontent.com/52594760/104122664-a774b280-5389-11eb-8947-4558013bf750.png>

이어서 남아있는 man1 객체가 소멸될 차례이다. 따라서 man1 객체의 소멸자에 의해 다음 문장이 실행되어야 한다.

``` C++
delete []name;
```
그런데 man2 객체가 소멸되면서 name이 가리키던 문자열의 메모리를 소멸시켜버렸다. 따라서 소멸된 문자열을 재 소멸하는 문제가 발생하게 된다. 정리하면,
생성자 내에서 동적할당을 하는 경우, 디폴트 대입연산자는 두 가지 문제를 일으키므로 다음의 형태로 직접 대입 연산자를 재 정의해야한다.
* 깊은복사를 진행하도록 정의한다.
* 메모리 누수가 발생하지 않도록 깊은 복사에 앞서 메모리 해제의 과정을 거친다.

위 조건에 맞춰 예제 02_AssignShallowCopyError 예제의 Person 클래스를 대상으로 대입 연산자를 직접 정의해보자. 참고로 이미 정의해놓은 생성자를 참고하면 쉽게 구현이 가능하다. 

**상속 구조에서의 대입 연산자 호출**
대입 연산자는 생성자가 아니다. 이 이야기를 하는 이유는, 유도 클래스의 생성자에는 아무런 명시를 하지 않아도 기초 클래스의 생성자가 호출되지만, **유도 클래스의 대입 연산자에는 아무런 명시를 하지 않으면, 기초클래스의 대입 연산자가 호출되지 않는다**는 사실을 말하기 위해서 이다.
다음 예제를 보고 결과를 관찰하자. 그리고 디폴트 대입 연산자에 대한 나름의 결론을 내려보자

> 03_InheriAssignOperation.cpp 확인

**유도 클래스(Second 클래스)에 대입 연산자 오버로딩을 하지 않으면**
Second 클래스(유도 클래스)에 삽입된 디폴트 대입 연산자가 기초 클래스의 대입 연산자 까지 호출한다. 는 사실을 알려준다. 

유도클래스에 연산자 오버로딩을 하게된 뒤 컴파일 한뒤에 얻을수 있는 사실은 다음과 같다.
> 유도 클래스의 대입 연산자 정의에서, 명시적으로 기초 클래스의 대입 연산자 호출문을 삽입하지 않으면 기초클래스의 대입 연산자는 호출되지 않아서, 기초 클래스의 멤버 변수는 멤버 대 멤버 복사대상에서 제외된다.

때문에 유도 클래스의 대입 연산자를 정의 해야하는 상황에 놓이게 되면, 기초 클래스의 대입 연산자를 명시적으로 호출 해야한다. 즉 위 예제에서 Second 클래스의 대입 연산자는 다음의 형태로 정의가 되어야 한다.

``` C++
Second& operator=(const Second& ref)
{
    cout << "Second operator=()" << endl;
    Frist::operator=(ref);      // 기초클래스의 대입 연산자 호출을 명령
    num3 = ref.num3;
    num4 = ref.num4;
    return *this;
}
```
위에 정의된 ref는 Second 클래스의 참조자 이기 때문에 First 클래스의 operator= 의 참조자(매개변수) ref가 Second형 이어도 참조할 수 있다.

문제 11-1 [깊은 복사를 하는 대입 연산자의 정의]
