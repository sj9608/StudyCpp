11-1 반드시 해야 하는 대입 연산자의 오버로딩
---
대입연산자의 오버로딩은 그 성격이 복사 생성자와 매우 유사하다. 따라서 복사 생성자에 대한 이해를 바탕으로 대입 연산자의 오버로딩을 이해하자.

**객체간 대입 연산의 비밀 : 디폴트 대입 연산자**
복사 생성자에 대한 대표적인 특성이다.
* 정의하지 않으면 디폴트 복사 생성자가 삽입된다.
* 디폴트 복사 생성자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
* 생성자 내에서 동적할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의 해야한다.

다음은 대입 연산자의 대표적인 특성이다.
* 정의하지 않으면 **디폴트 대입 연산자**가 삽입된다.
* 디폴트 대입 연산자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
* 연산자 내에서 동적할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의 해야한다.

개념만 놓고 보면 특성은 같지만 **호출되는 시점**에는 차이가 있다.

복사 생성자가 호출되는 대표적인 상황은 다음과 같다.
``` C++
int main(void)
{
    Point pos1(1, 5);
    Point pos2 = pos1;
    . . . .
}
```

여기서 중요한 사실은 새로 생성하는 객체 pos2의 초기화에 기존에 생성된 객체 pos1이 사용 되었다는 점 이다.

다음은 대입연산자가 호출되는 대표적인 상황이다.
``` C++
int main(void)
{
    Point pos1(5, 7);
    Point pos2(9, 10);
    pos2 = pos1;
    . . . .
}
```
여기서 중요한 사실은 **pos2도, 그리고 pos1도 이미 생성 및 초기화가 진행된 객체라는 사실**이다. 즉, 기존에 생성된 두 객체간의 대입연산 시에는 대입 연산자가 호출된다. 

그런데 우리는 이미 연산자 오버로딩을 공부한 상태이니 위의 대입연산의 문장은 다음과 같이 해석됨을 알 수 있다.

``` C++
pos2.operator=(pos1);
```

그럼 지금까지 언급한 대입 연산자의 특성을 확인하기 위한 예제를 하나 제시하겠다. 이 예제에서는 두 개의 클래스를 정의하는데, 한 클래스에는 대입연산자를 정의했고, 다른 클래스에는 대입연산자를 정의 하지 않았다.
> 01_FirstOperationOverloading.cpp

위의 실행결과를 통해서 확인 할 수 있는 사실은 다음과 같다.
> 분명 디폴트 대입 연산자가 삽입되어 멤버 대 멤버의 복사가 진행된다.

그리고 fob1 = fob2 = fsrc; 구문을 통해서 반환형도 예측이 가능하다. 즉, 위에서 정의한 First 클래스에 자동으로 삽입된 디폴트 연산자는 다음과 같다.

``` C++
First& operator=(const First& ref)
{
    num1 = ref.num1;
    num2 = ref.num2;
    return *this;
}
```

따라서 위의 함수를 First 클래스에 직접 삽입해도 실행 결과에는 차이가 없다. 참고로 우리는 다음의 문장을 보면, 

``` C++
int main(void)
{
    Second s1(10, 20);
    Second s2(11, 22);
    s2 = s1;
    . . .
}
```

> 동일한 자료형의 두 객체간에 대입연산이 허용되네?

위와 같이 생각 할 수 있다. 그러나 앞서 보였듯이, 객체간의 대입연산은 C언어의 구조체 변수간의 대입연산과 본질적으로 다르다.

이는 단순한 대입연산이 아닌, 대입 연산자 오버로딩을 한 함수의 호출이기 때문이다.

**디폴트 대입 연산자의 문제점**
기존에 보였던 디폴트 복사 생성자와 비슷한 문제이다. 물론 해결책도 비슷하다. 
이 예제는 Chapter05에서 디폴트 복사 생성자의 문제점을 언급할 때 사용했던 예제를 수정한 것이다.

> 02_AssignShallowCopyError.cpp


