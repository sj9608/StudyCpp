10-2 단항 연산자의 오버로딩
---
피연산자가 두 개인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수이다. 그리고 이에 따른 연산자 오버로딩의 차이점은 매개변수의 개수에서 발견된다.

**증가, 감소 연산자의 오버로딩**
대표적인 단항연산자로는 다음 두 가지가 있다.
* 1 증가 연산자 ++
* 1 감소 연산자 --

앞서 정의한 Point 클래스에 ++ 연산자가 오버로딩 되어있다고 가정해보자. 이런 경우 다음의 형태로 문장 구성이 가능하다

``` C++
++pos; // pos 는 Point 객체
```

> 호출되는 함수의 이름은 ++연산자와 키워드 operator를 연결해 완성되므로 operator++ 입니다.

멤버 함수의 형태로 오버로딩이 된 경우엔 pos의 멤버함수가 호출되는 형태이니, 다음과 같이 해석되어야 한다.

``` C++
pos.operator++();
```

전달인자가 없는 이유는 단항 연산자를 오버로딩 했기 때문이다. 하나있는 피연산자의 멤버함수를 호출하는 형태이기 때문에. 

반면, 전역함수의 형태라면 피연산자가 모두 인자로 전달되므로 다음과 같이 해석되어야 한다.

``` C++
operator++(pos);
```

이를 그림으로 표현하면 다음과 같다. 

<img width="400" alt="image" src="https://user-images.githubusercontent.com/52594760/103981383-0b01b300-51c5-11eb-855f-9878b3c21860.png">

그럼 예제를 통해 단항 연산자의 오버로딩을 확인해 보자.
> 01_OneOpndOverloading.cpp 예제 확인

++ 연산은 멤버함수로 오버로딩 되었기 때문에 다음과 같이 해석이 가능하다.
``` C++
pos.operator++();
```

반면, -- 연산은 전역함수로 오버로딩 되었기 때문에 다음과 같이 해석이 가능하다.

``` C++
operaotr--(pos);
```

``` C++
++(++pos);
--(--pos);
```

위 문장구성이 가능한 이유는 연산에서 자기 자신을 객체로 반환하고 있기 때문이다.
```
Point& operator++()
{
    ++xpos;
    ++ypos;
    return *this;
}
```
this는 객체 자신의 포인터 값을 의미하므로, *this는 객체 자신을 의미한다. 반환형이 참조형으로 선언되어있기 때문에 객체 자신을 참조할 수 있는 '참조 값'이 반환된다. 반환형으로 Point 형이 선언된다면 객체 자신의 복사본을 반환을 하게 된다.

그림으로 표현하면 다음과 같다.

<img width="600" alt="image" src="https://user-images.githubusercontent.com/52594760/103983570-cf68e800-51c8-11eb-8b43-7b1f9a06e889.png">

---
문제 10-2