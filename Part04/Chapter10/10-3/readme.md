10-3 교환 법칙 문제의 해결
---

교환 법칙이란 'A+B 의 결과는 B+A와 같음' 을 뜻한다. 즉, 연산자를 중심으로 한 피연산자의 위치는 연산의 결과에 아무런 영향을 미치지 않는다는 법칙이다. 곱셈, 덧셈이 있다.

**자료형이 다른 두 피연산자를 대상으로 하는 연산**
다음 예제를 확인해보고 무엇이 문제인지 확인해보자.
> 01_PointMultipleOverloading.cpp

``` C++
cpy = pos * 3; 
```
위 문장은 다음의 형태로 구성해도 동일한 결과를 보여야 한다.(보이도록 구현하는 것이 좋다)

``` C++
cpy = 3 * pos;
```
하지만 위 예제에서 오버로딩 한 형태로는 이 연산이 불가능하다. 멤버함수의 형태로 오버로딩이 되면, 멤버함수가 정의된 클래스의 객체가 오버로딩 된 연산자의 왼편에 와야하기 때문이다.

---
**객체간의 대입연산 **
``` C++
cpy = pos * 3;
cpy = pos * 3 * 2; 
```
위의 문장에서 이미 생성된 객체를 대상으로 대입연산을 진행 하였고 그 결과 객체간 멤버 대 멤버 복사가 진행된 것을 알 수 있다. 이 역시 연산자 오버로딩과 관계가 있는데 이에 관해선 다음 챕터에서 설명함.

**교환 법칙 성립을 위한 구현**

``` C++
cpy = 3 * pos;
```
이 교환법칙이 성립하도록 예제를 확장하려면 곱셈 연산자를 전역함수의 형태로 오버로딩 하는수 밖에 없다. 즉 위 문장이 다음과 같이 해석되도록 연산자를 오버로딩 해야한다.

``` C++
cpy = operator(3, pos);
```

이를 위해선 operator* 함수를 다음과 같이 정의해야 한다.

``` C++
Point operator(int times, Point &ref)
{
    Point pos(ref.xpos * times, ref.ypos * times);
    return pos;
}
```

혹은 다음과 같이 정의해도 된다.

``` C++
Point operator(int times, Point& ref)
{
    return ref * tiems;
}
```
이를 반영해서 만든 예제를 확인하자.
> 02_CommuMultipleOperation.cpp

이 예제에서 처럼 전역함수를 기반으로 연산자를 오버로딩 해야하는 경우도 있으니, 전역함수 기반의 연산자 오버로딩에도 익숙해지자.