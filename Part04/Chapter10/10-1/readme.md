10-1 연산자 오버로딩의 이해와 유형
---
함수가 오버로딩 되면, 오버로딩 된 수만큼 다양한 기능을 제공한다. 마찬가지로 연산자의 오버로딩을 통해서, 기존에 존재하던 연산자의 기본 기능이외에 다른 기능을 추가할 수 있다.

**operator+ 라는 이름의 함수**
다음 예제를 이해하면 연산자 오버로딩은 쉽게 정복이 가능하다. 
> 01_FirstOperationOverloading.cpp

이 예제에 operator+() 함수를 통해 다음과 같은 사실을 알 수 있다.
* pos3 = pos1.operator+(pos2) 의 표현과
* pos4 = pos1 + pos2; 의 표현이 같다는 사실이다.

> pos1 + pos2가 pos1.operator+(pos2)의 다른 표현이 되기위해서 약속된 변환 규칙이 있다.

연산자 오버로딩은 일종의 약속이라고 할 수 있다. 앞선 예제는 멤버함수에 의한 연산자 오버로딩의 한 예 이다. 컴파일러가 pos1 + pos2의 연산을 pos1.operator+(pos2)로 컴파일 한다.


연산자 오버로딩의 방법에는 멤버함수에 의한 방법과 전역변수에 의한 방법이 있다.
연산자를 오버로딩한 함수도 const로 선언이 가능하다.

**연산자를 오버로딩 하는 두 가지 방법**
연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.
* 멤버함수에 의한 연산자 오버로딩
* 전역함수에 의한 연산자 오버로딩

pos1+pos2 같은 경우 어떻게 오버로딩 했느냐에 따라 해석하는 방법이 다음과 같이 두가지로 나뉘게 된다.
* pos1.operator+(pos2); // 멤버함수로 오버로딩 된 경우
* operator+(pos1, pos2); // 전역함수로 오버로딩 된 경우

참고로 동일한 자료형을 대상으로 + 연산자를 전역함수 기반, 멤버함수 기반으로 동시에 오버로딩할 경우, 멤버함수가 기반으로 오버로딩된 함수가 호출된다.
다음 예제는 전역함수를 기반으로 연산자를 오버로딩한 예제이다.
> 02_GFunctionOverloading.cpp

위 예제는 Point 클래스에 삽입된 friend 선언으로 인해, Point 클래스의 private 멤버 변수에 접근해 연산자를 오버로딩한 적절한 예제이다. 
✅ **특별한 경우가 아니라면 멤버함수 기반으로 연산자를 오버로딩 하는 게 낫다.**

❗️**연산자 오버로딩 시 주의사항**
✅ 본래의 의도를 벗어난 혀태의 연산자 오버로딩은 좋지 않다.
* 연산의 본래의 의도를 충실히 반영해야 혼란을 최소화 할 수 있다.

✅ 연산자의 우선순위와 결합성은 바뀌지 않는다.

✅ 매개변수의 디폴트 값 설정이 불가능하다.
* 피연산자의 자료형에 따라 오버로딩한 함수의 호출이 결정되기 때문에 디폴트 값을 설정한다는 것은 말이 안된다. 연산자 오버로딩의 특성상 디폴트 값을 갖게 되면 함수의 호출관계가 매우 불분명해 지기 때문에 허용되지 않는다.

✅ 연산자의 순수 기능까지 덮을 순 없다.
``` C++
int operator+(const int num1, const int num2)
{
    return num1 * num2;
}
```
int형 데이터의 +연산은 이미 그 의미가 정해져 있기 때문에 이것을 변경하는 위와 같은 함수의 정의는 허용되지 않는다.

**연산자 오버로딩이라 이름이 붙은이유**
``` C++
int num = 3 + 4;
Point pos3 = pos1 + pos2;
```
함수가 오버로딩 되면 전달되는 인자(매개변수)의 자료형에따라 호출되는 함수가 달라진다. 이와 유사하게 위 두문장에서 보이듯이 연산자가 오버로딩 되면, 피연산자의 종류에 따라 연산의 방식이 달라진다. 그래서 연산자 오버로딩이라 불리는 것이다.