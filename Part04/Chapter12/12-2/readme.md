12-2 문자열 처리 클래스의 정의
---
이번에는 12-1의 예제 01_STDString.cpp 에서 string 클래스를 대체할 수 있는 (대문자) String 클래스(직접 정의하는 String 클래스)를 구현해 보고자 한다.

**표준 string 클래스의 분석**
먼저, 예제 01_STDString.cpp의 string 클래스를 대체하는 String 클래스의 정의를 위해서 어떠한 것들이 요구되는지 하나씩 정리해 보겠다.

✅ **하나. 문자열을 인자로 전달받는 생성자의 정의**
앞서 보인 예제에서는 다음의 형태로 string 객체를 생성하였다.
``` C++
string str1 = "I like ";
string str2 = "string class";
```

그런데, 이는 문자열을 전달받는 생성자의 호출로 이어진다. 즉, 다음의 문장과 동일한 문장이다.

``` C++
string str1("I like ");
string str2("string class");
```
따라서 이에 적절한 생성자를 정의해야 한다.

✅ **둘. 생성자, 소멸자, 복사 생성자 그리고 대입 연산자의 정의**
우리가 구현할 String 클래스는 문자열을 저장 및 표현하는 클래스이다. 그런데 저장하고자 하는 문자열의 길이가 일정치 않다. 따라서 문자열의 저장을 위한 메모리 공간을 생성자 내에서 동적으로 할당해야 한다. 그리고 이로 인해서 소멸자를 정의해야하며, 깊은 복사를 하는 복사 생성자와 대입 연산자 까지 함께 정의하고자 한다.

✅ **셋. 결합된 문자열로 초기화된 객체를 반환하는 + 연산자의 오버로딩**
예제 01_STDString.cpp 의 9행에는 다음의 문장이 있다.

``` C++
string str3 = str1 + str2;
```

이 연산의 결과로 str1, str2는 변화가 없지만 str3은 str1과 str2가 지니는 문자열을 합한 문자열로 초기화 된다. 이는 str1, str2 연산결과로 반환된 값이 str3의 생성자로 전달된 결과이다. 이 상황에서 생각해볼 수 있는 + 연산자의 반환 값은 다음 두 가지 이다.
* 문자열의 주소 값(str1, str2가 지니고 있는 문자열을 합한 문자열의 주소 값)
* string 객체(str1과 str2가 지니고 있는 문자열을 합한 문자열을 저장하고 있는 객체)

어떠한 값을 반환하도록 오버로딩을 해도 동일한 결과를 보장할 수 있지만, 우리는 여기서 + 연산의 결과로 객체가 반환되도록 정의하겠다.

✅ **넷. 문자열을 덧붙이는 += 연산자의 오버로딩**
예제 01_STDString.cpp의 15행 에는 다음의 문장이 있다.
``` C++
str1 += str2;
```
글고 연산의 결과로 str2가 지니고 있는 문자열이 str1이 지니는 문자열의 뒤에 덧붙여진 것을 예제를 통해서 확인 하였다. 이렇게 동작하도록 += 연산자를 오버로딩 해야한다.

✅ **다섯. 내용비교를 진행하는 == 연산자의 오버로딩**
main 함수의 if 문에서 == 연산을 통해 str1과 str3이 가지는 문자열의 내용비교를 하는 부분이 존재한다. == 연산자가 객체에 저장된 문자열의 내용을 비교하도록 오버로딩 해야한다.

✅ **여섯. 콘솔입출력이 가능하도록 <<, >> 연산자의 오버로딩**
string 객체를 대상으로 << 연산자를 이용한 출력과 >> 연산자를 이용한 입력을 보이고 있다.
이것이 가능하도록 << 연산자와 >> 연산자를 오버로딩 해야한다.

---
위에서 정리한 6가지 기능을 모두 완성해서 String 클래스를 정의하면 예제 01_STDString.cpp에서 표준 string 클래스를 대체할 수 있다. 

직접 위의 기능을 가진 String 클래스를 정의해 보고 다음과 비교해보자.
