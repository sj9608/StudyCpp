12-2 문자열 처리 클래스의 정의
---
이번에는 12-1의 예제 01_STDString.cpp 에서 string 클래스를 대체할 수 있는 (대문자) String 클래스(직접 정의하는 String 클래스)를 구현해 보고자 한다.

**표준 string 클래스의 분석**
먼저, 예제 01_STDString.cpp의 string 클래스를 대체하는 String 클래스의 정의를 위해서 어떠한 것들이 요구되는지 하나씩 정리해 보겠다.

✅ **하나. 문자열을 인자로 전달받는 생성자의 정의**
앞서 보인 예제에서는 다음의 형태로 string 객체를 생성하였다.
``` C++
string str1 = "I like ";
string str2 = "string class";
```

그런데, 이는 문자열을 전달받는 생성자의 호출로 이어진다. 즉, 다음의 문장과 동일한 문장이다.

``` C++
string str1("I like ");
string str2("string class");
```
따라서 이에 적절한 생성자를 정의해야 한다.

✅ **둘. 생성자, 소멸자, 복사 생성자 그리고 대입 연산자의 정의**
우리가 구현할 String 클래스는 문자열을 저장 및 표현하는 클래스이다. 그런데 저장하고자 하는 문자열의 길이가 일정치 않다. 따라서 문자열의 저장을 위한 메모리 공간을 생성자 내에서 동적으로 할당해야 한다. 그리고 이로 인해서 소멸자를 정의해야하며, 깊은 복사를 하는 복사 생성자와 대입 연산자 까지 함께 정의하고자 한다.

✅ **셋. 결합된 문자열로 초기화된 객체를 반환하는 + 연산자의 오버로딩**
예제 01_STDString.cpp 의 9행에는 다음의 문장이 있다.

``` C++
string str3 = str1 + str2;
```

이 연산의 결과로 str1, str2는 변화가 없지만 str3은 str1과 str2가 지니는 문자열을 합한 문자열로 초기화 된다. 이는 str1, str2 연산결과로 반환된 값이 str3의 생성자로 전달된 결과이다. 이 상황에서 생각해볼 수 있는 + 연산자의 반환 값은 다음 두 가지 이다.
* 문자열의 주소 값(str1, str2가 지니고 있는 문자열을 합한 문자열의 주소 값)
* string 객체(str1과 str2가 지니고 있는 문자열을 합한 문자열을 저장하고 있는 객체)

어떠한 값을 반환하도록 오버로딩을 해도 동일한 결과를 보장할 수 있지만, 우리는 여기서 + 연산의 결과로 객체가 반환되도록 정의하겠다.

✅ **넷. 문자열을 덧붙이는 += 연산자의 오버로딩**
예제 01_STDString.cpp의 15행 에는 다음의 문장이 있다.
``` C++
str1 += str2;
```
글고 연산의 결과로 str2가 지니고 있는 문자열이 str1이 지니는 문자열의 뒤에 덧붙여진 것을 예제를 통해서 확인 하였다. 이렇게 동작하도록 += 연산자를 오버로딩 해야한다.

✅ **다섯. 내용비교를 진행하는 == 연산자의 오버로딩**
main 함수의 if 문에서 == 연산을 통해 str1과 str3이 가지는 문자열의 내용비교를 하는 부분이 존재한다. == 연산자가 객체에 저장된 문자열의 내용을 비교하도록 오버로딩 해야한다.

✅ **여섯. 콘솔입출력이 가능하도록 <<, >> 연산자의 오버로딩**
string 객체를 대상으로 << 연산자를 이용한 출력과 >> 연산자를 이용한 입력을 보이고 있다.
이것이 가능하도록 << 연산자와 >> 연산자를 오버로딩 해야한다.

---
위에서 정리한 6가지 기능을 모두 완성해서 String 클래스를 정의하면 예제 01_STDString.cpp에서 표준 string 클래스를 대체할 수 있다. 

직접 위의 기능을 가진 String 클래스를 정의해 보고 다음과 비교해보자.

---

**StringAns.cpp 예제 부연 설명**
디폴트 생성자를 확인해보면 다음과 같은 형태로 정의 되어있다.
``` C++
String()
{
    len = 0;
    str = NULL;
}
```
이는 문자열을 입력 받을 목적으로, 다음의 형태로 객체를 생성할 수 있게 하기 위해서 정의된 생성자 이다.

``` C++
String emptyStr;
```
때문에 멤버변수 str에는 NULL 이 저장될 수도 있다. 그래서 멤버변수 str을 대상으로 delete 연산을 하기에 앞서, str에 저장된 값이 NULL 인지를 검사하는 코드를 소멸자에 포함해서 곳곳에서 확인할 수 있다.
그리고 복사 생성자, 대입 연산자는 깊은 복사를 진행하도록 정의되었다는 점을 제외하곤 특별할게 없다.

이번에는 오버로딩된 + 연산자를 보자.

``` C++
String operator+(const String& s)
{
    char *tempstr = new char[len + s.len - 1];
    strcpy(tempstr, str);
    strcat(tempstr, s.str);

    String temp(tempstr);
    delete []tempstr;
    return temp;
}
```
'+' 연산자의 본래 목적은 새로운 값을 만들어내는 연산자이지, 피연산자의 값을 변경시키는 연산자가 아니기 때문에 const 선언을 하였고 피연산자의 정보를 참조해서 새로운 객체를 만들어 반환하고 있다. 그리고 할당할 메모리 공간의 길이를 계산하는데 있어 -1을 한 이유는 멤버변수 len에 저장된 문자열의 길이 정보 끝을 의미하는 NULL 문자도 포함되어 있기 때문이다. NULL 이 두 번 계산되었으니, 하나를 빼야 한다.

다음은 += 연산자의 오버로딩 결과이다.
``` C++
String& operator+=(const String& s)
{
    len += (s.len - 1);
    char* tempstr = new char[len];
    strcpy(tempstr, str);
    strcat(tempstr, s.str);

    if(str != NULL)
        delete []str;
    str = tempstr;
    return *this;
}
```
위 함수에서, 배열은 확장이 불가능하기 때문에 덧붙여질 문자열의 길이를 감안해서 배열을 재할당한 다음에, 원본 문자열을 복사하고, 추가할 문자열을 덧붙이고 있다. 참고로 위 예제에서 정의한 += 연산자는 오버로딩된 +연산자를 이용해 다음과 같이 간단하게도 정의가 가능하다.

``` C++
String& operator+=(const String& s)
{
    *this = *this + s;
    return *this;
}
```
이러한 형태의 정의는 간결해 보이고 이해하기도 좋지만, 덧셈의 과정에서 객체가 추가로 생성되는 단점이 있다. 하지만 컴퓨팅 파워가 좋은 환경이라면 이 정도는 단점이 될 수 없으니, 이러한 형태의 구현도 생각해볼 만하다.